# 面试总结



### Mybatis 中使用xml文件接口的原理

1. 读取配置文件mybatis-config.xml, 
2. 然后创建sqlSessionFactoryBuilder对象,
3. 再创建SqlSessionFactory工厂, 
4. 根据工厂再创建sqlSession会话, 这个sqlSession就相当于是JDBC中的connection链接对象,
5. 然后再根据sqlSession.getMapper("UserMapper.xml") 文件,获取全类名,然后通过反射创建 UserMapper的代理对象, 
6. 使用代理完成对接口的实现



### SpringIOC的原理

1. 加载xml配置文件xml   ClassPathXmlApplicationContext, 并创建beanFactory工厂
2. 再根据配置文件中的bean标签进行扫描获取, 得到有唯一的class全类名
3. 使用反射创造出该对象, 



### SpringMVC中对于参数的获取

1. 若表单提交的name与方法处理的**形参**名称不同,则是用***@RequestParam***注解,
2. **对象参数接收参数值**
   * *使用对象接收参数,对象的类中的属性值名称需与提交的name值相同, 则SpringMVC自动调用该类的无参构造方法,根据传递的参数调用对应的set方法用以赋值,完成对象传参.*



### 数据库中关于多表查询

[mysql多表查询](https://blog.csdn.net/plg17/article/details/78758593)

1. #### **内连接**

   关键字：inner join on

   ```sql
   语句：select * from a_table a inner join b_table b on a.a_id = b.b_id;
   ```

   说明：组合两个表中的记录，返回关联字段相符的记录，也就是返回两个表的交集（阴影）部分。

   ![image-20210327163628859](C:\Users\j1781\Desktop\learnCode\面试\面试总结\img\inner-join.png)

2. #### 左连接(左外链接)

   **关键字：left join on / left outer join on**

   ```sql
   语句：select * from a_table a left join b_table b on a.a_id = b.b_id;
   select * from a_table a, b_table b where a.a_id = b.b_id;  (简写)
   ```

   说明：

   left join 是left outer join的简写，它的全称是左外连接，是外连接中的一种。

   左(外)连接，左表(a_table)的记录将会全部表示出来，而右表(b_table)只会显示符合搜索条件的记录。右表记录不足的地方均为NULL。

   ![image-20210327163732778](C:\Users\j1781\Desktop\learnCode\面试\面试总结\img\left-join.png)

3. #### 右连接(右外连接)

   **关键字：right join on / right outer join on**

   ```sql
   语句：select * from a_table a right outer join b_table b on a.a_id = b.b_id;
   ```

   说明：
   right join是right outer join的简写，它的全称是右外连接，是外连接中的一种。
   与左(外)连接相反，右(外)连接，左表(a_table)只会显示符合搜索条件的记录，而右表(b_table)的记录将会全部表示出来。左表记录不足的地方均为NULL。

   ![image-20210327163916755](C:\Users\j1781\Desktop\learnCode\面试\面试总结\img\right-join.png)

### 对于Java中List集合中, 遍历中如何安全的删除元素

因为list的底层是数组, 在进行增删时的原理就是创建一个新的数组,将其余元素复制过去, 然遍历的时候删除有很高的安全隐患

所以, 只能使用iterator迭代器进行删除 hashNext()   next()

```java
    /** 
     * 使用Iterator的方式可以顺利删除和遍历 
     */  
    public void iteratorRemove() {  
        List<Student> students = this.getStudents();  
        System.out.println(students);  
        Iterator<Student> stuIter = students.iterator();  
        while (stuIter.hasNext()) {  
            Student student = stuIter.next();  
            if (student.getId() % 2 == 0)  
                stuIter.remove();//这里要使用Iterator的remove方法移除当前对象，如果使用List的remove方法，则同样会出现ConcurrentModificationException  
        }  
        System.out.println(students);  
    }  
```



### Java集合中为什么set是不重复的

​	set集合会让两两对象，先调用自己的hashCode()方法得到彼此的哈希值(所谓的内存地址)
​	然后比较两个对象的哈希值是否相同，如果不相同则直接认为两个对象不重复。
​	如果哈希值相同，会继续让两个对象进行equals比较内容是否相同，如果相同认为真的重复了
​	如果不相同认为不重复。



### hashCode 与equals方法

 	**hashCode()方法和equals()方法的作用其实一样，在Java里都是用来对比两个对象是否相等一致。**

```xml
那么equal()既然已经能实现对比的功能了，为什么还要hashCode()呢？因为重写的equals()里一般比较的比较全面

比较复杂，这样效率就比较低，而利用hashCode()进行对比，则只要生成一个hash值进行比较就可以了，效率很高。

     那么hashCode()既然效率这么高为什么还要equal()呢？ 因为hashCode()并不是完全可靠，有时候不同的对象他们

生成的hashcode也会一样（生成hash值得公式可能存在的问题），所以hashCode()只能说是大部分时候可靠，并不是

绝对可靠，所以我们可以得出：

 1.equals()相等的两个对象他们的hashCode()肯定相等，也就是用equals()对比是绝对可靠的。

 2.hashCode()相等的两个对象他们的equals()不一定相等，也就是hashCode()不是绝对可靠的。

      所有对于需要大量并且快速的对比的话如果都用equals()去做显然效率太低，所以解决方式是，每当需要对比的时候，

首先用hashCode()去对比，如果hashCode()不一样，则表示这两个对象肯定不相等（也就是不必再用equals()去再对比

了）,如果hashCode()相同，此时再对比他们的equals()，如果equals()也相同，则表示这两个对象是真的相同了，这样既

能大大提高了效率也保证了对比的绝对正确性！

总结如下：
1.若重写了equals(Object obj)方法，则有必要重写hashCode()方法。

2.若两个对象equals(Object obj)返回true，则hashCode（）也必须返回相同的int数。

3.若两个对象equals(Object obj)返回false，则hashCode（）不一定返回不同的int数。

4.若两个对象hashCode（）返回相同int数，则equals（Object obj）不一定返回true。

5.若两个对象hashCode（）返回不同int数，则equals（Object obj）一定返回false。

6.同一对象在执行期间若已经存储在集合中，则不能修改影响hashCode值的相关信息，否则会导致内存泄露问题。

7.hashcode方法只有在集合中用到，将对象放入到集合中时，首先判断要放入对象的hashcode值与集合中的任意一个

元素的hashcode值是否相等，如果不相等直接将该对象放入集合中。如果hashcode值相等，然后再通过equals()方法判

断要放入对象与集合中的任意一个对象是否相等，如果equals()判断不相等，直接将该元素放入到集合中，否则不放入。

8.equals()方法是用于比较对象的内容是否相等。

```

